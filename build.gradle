buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.sun.mail:javax.mail:1.6.2'
    }
}

plugins {
    id 'java'
    id 'jacoco'
    id 'maven-publish'
    id 'com.github.spacialcircumstances.gradle-cucumber-reporting' version '0.1.25'
    id 'org.sonarqube' version '3.5.0.2730'  // Compatible with SonarQube 4.x
}

import javax.mail.*
import javax.mail.internet.*

group = 'com.example'
version = '1.0'

// Java 11 configuration
java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

repositories {
    mavenCentral()
}

dependencies {
    // Cucumber dependencies
    testImplementation 'io.cucumber:cucumber-java:6.10.4'
    testImplementation 'io.cucumber:cucumber-junit:6.10.4'
    testImplementation 'junit:junit:4.13.2'
}

// Test configuration
test {
    useJUnit()
    reports {
        html.required = true
        junitXml.required = true
    }
    finalizedBy jacocoTestReport
}

// Cucumber reporting configuration
cucumberReports {
    outputDir = file('build/reports/cucumber')
    buildId = '0'
    reports = files('build/reports/cucumber/cucumber.json')
}

task cucumberReport {
    dependsOn test
    doLast {
        println "Cucumber reports generated in build/reports/cucumber"
    }
}

test {
    systemProperty 'cucumber.plugin',
            'pretty, html:build/reports/cucumber/cucumber.html, json:build/reports/cucumber/cucumber.json'
}

jacoco {
    toolVersion = "0.8.7"  // Compatible with Java 11
}

jacocoTestReport {
    dependsOn test

    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                    '**/test/**',
                    '**/tests/**'
            ])
        }))
    }
}

// SonarQube configuration
sonarqube {
    properties {
        property "sonar.projectKey", "matrix-api"
        property "sonar.projectName", "Matrix API"
        property "sonar.projectVersion", "${version}"
        property "sonar.host.url", "http://localhost:9000"
        property "sonar.sourceEncoding", "UTF-8"
        property "sonar.sources", "src/main/java"
        property "sonar.tests", "src/test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.java.test.binaries", "build/classes/java/test"
        property "sonar.coverage.jacoco.xmlReportPaths",
                "build/reports/jacoco/test/jacocoTestReport.xml"
    }
}

// Make sonarqube task depend on test
tasks.named('sonarqube') {
    dependsOn test, jacocoTestReport
}

// Javadoc configuration
javadoc {
    options.encoding = 'UTF-8'
    options.charSet = 'UTF-8'
    if (JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
    }
}

// Source JAR task
task sourceJar(type: Jar) {
    from sourceSets.main.allJava
    archiveClassifier = 'sources'
}

// Javadoc JAR task
task javadocJar(type: Jar) {
    from javadoc
    archiveClassifier = 'javadoc'
}

// Publishing configuration for mymavenrepo.com
publishing {
    publications {
        maven(MavenPublication) {
            groupId = project.group
            artifactId = project.name
            version = project.version

            from components.java

            // Include sources and javadoc
            artifact sourceJar
            artifact javadocJar
        }
    }

    repositories {
        maven {
            name = "myMavenRepo"
            url = "https://mymavenrepo.com/repo/cEmjfkxugPlzLxXg1A2B/"
            allowInsecureProtocol = true
            credentials {
                username = "myMavenRepo"
                password = "test0005"
            }
//                name = "LocalRepo"
//                url = uri('C:/Users/aimen/Documents/ESI/2 CS/S1/ogl/tp5/BuildTP/build/repo')

        }
    }
}

// 1.8 Notification Slack
task notifySlack {
    mustRunAfter 'publish' // Ensure it runs after publishing

    doLast {
        def webhookUrl = System.getenv('SLACK_WEBHOOK_URL') ?: ''
        
        if (!webhookUrl) {
            println "SLACK_WEBHOOK_URL environment variable not set. Skipping Slack notification."
            return
        }

        // The message (JSON format)
        def messagePayload = """{"text": "Build Success! The API has been successfully deployed to MyMavenRepo."}"""

        // Create the connection
        def url = new URL(webhookUrl)
        def connection = url.openConnection()
        connection.setRequestMethod("POST")
        connection.setRequestProperty("Content-Type", "application/json")
        connection.doOutput = true

        // Send the request
        def writer = new OutputStreamWriter(connection.outputStream)
        writer.write(messagePayload)
        writer.flush()
        writer.close()
        connection.connect()

        // Print response for verification
        println "--------------------------------------------------"
        println "Slack Notification Sent: ${connection.responseCode} ${connection.responseMessage}"
        println "--------------------------------------------------"
    }
}
// Ensure the notification runs only if publish succeeds
publish.finalizedBy notifySlack

// 1.9 Notification Mail
task sendMail {
    mustRunAfter 'notifySlack'

    doLast {
        // --- CONFIGURATION ---
        def to = "ma_azzouz@esi.dz" // Who receives the email (can be yourself)
        def from = "aimen.azzouz2015@gmail.com" // Your Gmail
        def host = "smtp.gmail.com"
        def password = "zmeo iezc rxyp wozv"
        // ---------------------

        Properties properties = System.getProperties()
        properties.setProperty("mail.smtp.host", host)
        properties.setProperty("mail.smtp.port", "587")
        properties.setProperty("mail.smtp.auth", "true")
        properties.setProperty("mail.smtp.starttls.enable", "true")

        Session session = Session.getInstance(properties, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(from, password)
            }
        })

        try {
            MimeMessage message = new MimeMessage(session)
            message.setFrom(new InternetAddress(from))
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to))
            message.setSubject("Build Success: Matrix API ${version}")
            message.setText("The build was successful. \n\nDeployed version 1.0 \nSlack notification has been sent.")

            Transport.send(message)
            println "--------------------------------------------------"
            println "Email Notification Sent Successfully"
            println "--------------------------------------------------"
        } catch (MessagingException mex) {
            println "Error sending email: " + mex.message
            // mex.printStackTrace() // Uncomment to debug errors
        }
    }
}

// Update the chain: Publish -> Slack -> Mail
publish.finalizedBy notifySlack
notifySlack.finalizedBy sendMail